## 멤버 참조
람다를 사용해 코드 블록을 다른 함수에 인자로 넘기는 방법을 살펴보았습니다.<br>
넘기려는 코드가 이미 함수로 선언된 경우는 어떻게 할가요? 그 함수를 호출하는 람다를 만들면 되겠지만 이는 중복입니다.
> kotlin에서는 자바8과 마찬가지로 함수를 값으로 바꿀 수 있습니다. 이때 이중 콜론 :: 을 사용합니다.

::을 사용하는 식을 `멤버 참조`라고 합니다. <br>
멤버 참조는 정확히 한 메서드를 호출하거나 한 프로퍼티에 접근하는 함수 값을 만들어줍니다.
<br><br>
우리가 흔히 사용하는 Compose 코드를 예시로 들어보겠습니다.
```kotlin
class MyViewModel : ViewModel() {
    fun onQueryChanged(query: String) {
        // query 값을 받아 처리하는 로직
        Log.d("ViewModel", "Query is: $query")
    }
}
@Composable
fun MyScreen(viewModel: MyViewModel) {
    var text by remember { mutableStateOf("") }

    TextField(
        value = text,
        // 람다 방식
        onValueChange = { newString -> viewModel.onQueryChanged(newString) }

        // 멤버 참조 방식
        onValueChange = viewModel::onQueryChanged 
    )
}
```
어떻게 이게 가능할가요?

우리가 가장 많이 쓰는 람다 방식은 값처럼 변경해본다면 아래와 같습니다.
```kotlin
val lambda: (String) -> Unit = { newText -> viewModel.onQueryChanged(newText) }
```
:: 멤버 참조는 함수를 값으로 표현하는 문법입니다.
viewModel::onQueryChanged는 이 표현은 viewModel의 onQueryChanged() 라는 멤버 함수를 가리키는 함수 참조 입니다.<br>
이 참조는 아래와 같은 타입을 가집니다.
```kotlin
(String) -> Unit
```
즉, 람다와 똑같은 함수 타입이기 때문에 onValueChange에 바로 넣을 수 있습니다.

그럼 대체 언제 멤버참조를 사용하고 언제 람다를 사용할가요?

---
## 멤버 참조와 람다
해당 내용은 [Kotlin. Lambda vs Method Reference](https://proandroiddev.com/kotlin-lambda-vs-method-reference-fdbd175f6845) 내용을 학습한 내용입니다.

<br>

Button 클래스가 있고 onClick람다를 가지고 있습니다.
```kotlin
class Button(
    private val onClick: () -> Unit
) {
    fun performClick() = onClick()
}
```

<br>

버튼클릭 리스너가 존재하고 perfromClick 클릭시 리스너의 onClick이 호출되게 할겁니다.
```kotlin
class ButtonClickListener {
    fun onClick() {
        println("Button clicked")
    }
}
```

<br>

이제 ScreenView가 있고 `lateinit`을 통해 초기화를 나중에 하겠다고 명시했습니다.<br>
그렇다면 onClick이 동작하기 위해서는 listener 객체가 초기화가 되어있어야겠죠?
```kotlin
class ScreenView {
    lateinit var listener: ButtonClickListener
    val button = Button { listener.onClick() }
}
```

<br>

메인 함수입니다. <br>
위에서 고려한대로 먼저 ScreenView의 리스너를 초기화 해주고 button.performClick 메서드를 호출해줍니다.<br>
실제로 돌려봐도 아무 문제가 없습니다.
```kotlin

fun main() {
    val screenView = ScreenView()
    screenView.listener = ButtonClickListener()
    screenView.button.performClick()
}
// "Button clicked"
```

<br>

그럼 ScreenView의 코드를 멤버 참조로 변경해볼가요?
```kotlin
class ScreenView {
    lateinit var listener: ButtonClickListener
    val button = Button(listener::onClick)
}
```
다시 메인 함수를 돌려보면 <br>
<img width="1229" height="136" alt="image" src="https://github.com/user-attachments/assets/1dcaa1fd-6295-4f5b-bfd0-49592f71ab30" /> <br>
`lateinit` 에러가 납니다.
<br><br>

람다를 사용했을 땐 잘 동작했는데 멤버 참조로 변경했다고 오류가 발생했습니다. <br>
왜 그럴가요? 그 이유는 디컴파일 코드를 통해 알 수 있습니다. 멤버 참조를 사용하는 ScreenView 디컴파일 코드를 같이 확인해보겠습니다.
```kotlin
public final class ScreenView {
   public ButtonClickListener listener;
   @NotNull // 버튼 생성자
   private final Button button = new Button(new Function0(this.getListener()) {
      // 람다는 Function 인터페이스를 구현하는 일반 익명 내부 클래스로 변환됩니다.
      // 버튼의 생성자 코드에서 this.getListener()를 통해 리스너를 가져오려 하고 있네요
      public final void invoke() {
         ((ButtonClickListener)this.receiver).onClick();
      }

      // $FF: synthetic method
      // $FF: bridge method
      public Object invoke() {
         this.invoke();
         return Unit.INSTANCE;
      }
   });
   public static final int $stable = 8;

   @NotNull
   public final ButtonClickListener getListener() {
      ButtonClickListener var10000 = this.listener;
      if (var10000 != null) {
         // 리스너가 null이 아닐 때만 리스너를 반환할 수 있습니다.
         return var10000;
      } else {
         // 리스너가 초기화되지 않았다면 Exception을 발생시키고 있습니다.
         Intrinsics.throwUninitializedPropertyAccessException("listener");
         return null;
      }
   }

   public final void setListener(@NotNull ButtonClickListener var1) {
      Intrinsics.checkNotNullParameter(var1, "<set-?>");
      this.listener = var1;
   }

   @NotNull
   public final Button getButton() {
      return this.button;
   }
}
```
코드 흐름을 보면 다음과 같습니다.
```kotlin
fun main() {
    val screenView = ScreenView() // 이때 버튼 생성자 코드도 같이 불리게 됨
    screenView.listener = ButtonClickListener()
    screenView.button.performClick()
}
```
- ScreenView() 객체가 생성될 때 ScreenView에 있는 Button도 생성됩니다.
- Button이 생성되니 Button 생성자 코드를 사용합니다.
- Button 생성자 코드에서 리스너를 가져오는데 리스너를 지정해주기 전입니다.
- 리스너가 초기화되지 않았으니 당연히 오류가 납니다.

<br><br>
그렇다면 람다를 사용했던 코드는 어떻게 디컴파일 될가요?
```kotlin
public final class ScreenView {
   public ButtonClickListener listener;
   @NotNull // 버튼 생성자 코드가 간결해짐
   private final Button button = new Button(ScreenView::button$lambda$0);
   public static final int $stable = 8;

   @NotNull
   public final ButtonClickListener getListener() {
      ButtonClickListener var10000 = this.listener;
      if (var10000 != null) {
         return var10000;
      } else {
         Intrinsics.throwUninitializedPropertyAccessException("listener");
         return null;
      }
   }

   public final void setListener(@NotNull ButtonClickListener var1) {
      Intrinsics.checkNotNullParameter(var1, "<set-?>");
      this.listener = var1;
   }

   @NotNull
   public final Button getButton() {
      return this.button;
   }

   private static final Unit button$lambda$0(ScreenView this$0) {
      this$0.getListener().onClick(); // 실제로 람다가 호출될때 참조로부터 getListner() 호출함
      return Unit.INSTANCE;
   }
}
```
즉 멤버 참조를 사용했을 때는 Button의 생성자 코드에 리스너를 참조했고 <br>
람다의 경우 람다가 호출될 때 ScreenView의 리스너를 가져와 사용하고 있습니다.

<br>

요약하자면, 멤버 참조를 사용할 때 변수의 인스턴스, 즉 사용하는 메서드가 호출 시점이 아닌 참조가 생성되는 순간에 고정된다는 점에서 람다와 다릅니다. <br>

즉, val 변수로 선언된 것은 변경될 일이 없으니 멤버 참조를 사용해도 무방합니다. <br>
하지만 var 가변이며 멤버 참조를 사용하고 있고 만약 변수가 변경될 수 있다면 원하는 결과를 얻지 못할 수 있습니다.

## 이해
아래 코드의 결과는 어떻게 될가요?
```kotlin
class Button(
    private val onClick: () -> Unit
) {
    fun performClick() = onClick()
}

class ButtonClickListener(
    private val name: String
) {
    fun onClick() {
        print(name)
    }
}

class ScreenView {
    var listener = ButtonClickListener("First")
    val buttonLambda = Button { listener.onClick() }
    val buttonReference = Button(listener::onClick)
}

fun main() {
    val screenView = ScreenView()
    screenView.listener = ButtonClickListener("Second")
    screenView.buttonLambda.performClick()
    screenView.buttonReference.performClick()
}
```
정답을 확인하기 전에 디컴파일 코드부터 확인해 보겠습니다.

```kotlin
public final class ScreenView {
   @NotNull
   private ButtonClickListener listener = new ButtonClickListener("First");
   @NotNull
   private final Button buttonLambda = new Button(ScreenView::buttonLambda$lambda$0); // Button { listener.onClick() } 
   @NotNull
   private final Button buttonReference; // Button(listener::onClick)
   public static final int $stable = 8;

   public ScreenView() {
      // Button(listener::onClick) buttonReference를 Button 생성자를 통해 생성합니다.
      // 즉 초기화가 되는 시점에 listener가 buttonReference참조가 생성되는 순간에 ButtonClickListener("First") 이녀석으로 고정됩니다.
      this.buttonReference = new Button(new Function0(this.listener) {
         public final void invoke() {
            ((ButtonClickListener)this.receiver).onClick();
         }

         // $FF: synthetic method
         // $FF: bridge method
         public Object invoke() {
            this.invoke();
            return Unit.INSTANCE;
         }
      });
   }

   @NotNull
   public final ButtonClickListener getListener() {
      return this.listener;
   }

   public final void setListener(@NotNull ButtonClickListener var1) {
      Intrinsics.checkNotNullParameter(var1, "<set-?>");
      this.listener = var1;
   }

   @NotNull
   public final Button getButtonLambda() {
      return this.buttonLambda;
   }

   @NotNull
   public final Button getButtonReference() {
      return this.buttonReference;
   }

   // 람다가 호출되었을 때 this$0을 통해 현재 ScreenView listener 참조를 가져와 변경된 ButtonClickListener("Second") 리스너를 반환합니다.
   private static final Unit buttonLambda$lambda$0(ScreenView this$0) {
      this$0.listener.onClick();
      return Unit.INSTANCE;
   }
}
```
그렇기 때문에 정답은 `SecondFirst`가 됩니다.
위에서도 보았지만 var 가변을 사용하고 있고 인스턴스가 변경되었다면 멤버 참조를 사용했을 때 이러한 점을 주의해야 합니다!



